# 设计模式学习代码
一些简单的设计模式实现和笔记.用于学习;  
                  _java_  
## Iterator模式:

_为什么要引入?_

- ​		引入Iterator后可以将遍历与实现分离开来.即遍历过程中不依赖于集合的方法进行实现;

**在Iterator模式中,Aggregate与Iterator这两个接口对应,并且其具体类也对应,但是一个ConcreteAggregate可以对应多个ConcreteIterator,通过不同的ConcreteIterator来实现不同的遍历要求,例如:跳跃遍历,向前,向后遍历等;**

_易错点_

- ​		Iterator中的next方法:<u>是指返回当前元素,并指向下一个元素;</u>不是返回下一个元素;  

*登场角色*
**Iterator（迭代器）**
该角色负责定义按顺序逐个遍历元素的接口（API）。在示例程序中，由 Iterator 接口扮演这个角色，它定义了 hasNext 和 next 两个方法。其中，hasNext 方法用于判断是否存在下一个元素，next 方法则用于获取该元素。

**ConcreteIterator（具体的迭代器）**
该角色负责实现 Iterator 角色所定义的接口（API）。在示例程序中，由 BookShelfIterator 类扮演这个角色。该角色中包含了遍历集合所必需的信息。在示例程序中，BookShelf 类的实例保存在 bookShelf 字段中，被指向的书的下标保存在 index 字段中。

**Aggregate（集合）**
该角色负责定义创建 Iterator 角色的接口（API）。这个接口（API）是一个方法，会创建出“按顺序访问保存在我内部元素的人”。在示例程序中，由 Aggregate 接口扮演这个角色，它里面定义了 iterator 方法。

**ConcreteAggregate（具体的集合）**
该角色负责实现 Aggregate 角色所定义的接口（API）。它会创建出具体的 Iterator 角色，即 ConcreteIterator 角色。在示例程序中，由 BookShelf 类扮演这个角色，它实现了 iterator 方法。
## Adapter模式

**特点:** 

- 通过该模式可以很方便地创建我们需要的方法群;
- 便于排查系统bug,当出现bug时,我们可以只排查我们所创建的适配器类(Adapter类);
- 可以在不改变现有程序的情况下，通过创建一个适配器，去扩展我们所需的程序;



**源角色（Adaptee）**：你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象。

**适配器角色（Adapter**）：适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：通过继承或是类关联的方式把源角色转换为目标角色。

**目标角色（Target）**：该角色定义把其他类转换为何种接口，也就是我们的期望接口。

**类适配器**
优点：可以根据需求重写Adaptee类的方法，使得Adapter的灵活性增强了。
缺点：有一定局限性。因为类适配器需要继承Target类，而Java是单继承机制，所以要求Adaptee类必须是接口。

**对象适配器**
优点：同一个Adapter可以把Adaptee类和他的子类都适配到目标接口。
缺点：需要重新定义Adaptee行为时，需要重新定义Adaptee的子类，并将适配器组合适配。

### 适用场景

- 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们。

## Template Method模式

_什么是Template Method模式?_

- 即在父类中定义处理流程的框架,在子类中实现具体处理;

_登场角色_

**AbstractClass(抽象类)**

不仅负责实现模板方法,还负责声明在模板方法中所使用到的抽象方法,抽象方法由其子类ConcreteClass类进行实现;

**ConcreteClass(具体类)**

实现AbstractClass类的抽象方法,实现的方法将会在AbstractClass角色的模板方法中被调用;

**应用场景**

在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同
子类实现。这就是一种模板模式。(使用例子:java的InputStream类)

*优点*:

- 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
- 它在父类中提取了公共的部分代码，便于代码复用。
- 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。

*缺点*:

- 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
- 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
- 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。

## 持续更新中....
