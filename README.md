# 设计模式学习代码
一些简单的设计模式实现和笔记.用于学习;  
                  _java_  
## Iterator模式:

_为什么要引入?_

- ​		引入Iterator后可以将遍历与实现分离开来.即遍历过程中不依赖于集合的方法进行实现;

**在Iterator模式中,Aggregate与Iterator这两个接口对应,并且其具体类也对应,但是一个ConcreteAggregate可以对应多个ConcreteIterator,通过不同的ConcreteIterator来实现不同的遍历要求,例如:跳跃遍历,向前,向后遍历等;**

_易错点_

- ​		Iterator中的next方法:<u>是指返回当前元素,并指向下一个元素;</u>不是返回下一个元素;  
# Adapter模式

**特点:** 

- 通过该模式可以很方便地创建我们需要的方法群;
- 便于排查系统bug,当出现bug时,我们可以只排查我们所创建的适配器类(Adapter类);
- 可以在不改变现有程序的情况下，通过创建一个适配器，去扩展我们所需的程序;



**源角色（Adaptee）**：你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象。

**适配器角色（Adapter**）：适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：通过继承或是类关联的方式把源角色转换为目标角色。

**目标角色（Target）**：该角色定义把其他类转换为何种接口，也就是我们的期望接口。

**类适配器**
优点：可以根据需求重写Adaptee类的方法，使得Adapter的灵活性增强了。
缺点：有一定局限性。因为类适配器需要继承Target类，而Java是单继承机制，所以要求Adaptee类必须是接口。

**对象适配器**
优点：同一个Adapter可以把Adaptee类和他的子类都适配到目标接口。
缺点：需要重新定义Adaptee行为时，需要重新定义Adaptee的子类，并将适配器组合适配。

## 适用场景

- 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们。

## 持续更新中....
